//go:build exclude
// +build exclude

// This is not part of the final package, this is just a script to build benchmarks.md doc file
// easily from the bench.txt output.
// Please, do not be critical about these line of codes, was just a simple way to execute with
// `go run benchtable.go` without any dependencies.
package main

import (
	"bufio"
	"fmt"
	"go/doc"
	"go/parser"
	"go/token"
	"io"
	"log"
	"os"
	"regexp"
	"strconv"
	"strings"
)

const importPath = "./omap/"

const introductionText = `# Benchmarks

This is the result of a series of benchmarks on each implementation to validate the assumptions
about design decision of each. Bellow is a formatted version of the results with my own
conclusions, you can see the raw results at [bench.txt](bench.txt) file.

To run the benchmarks your self, just do

` + "```sh" + `
make bench
` + "```" + `

You can generate the formatted output as bellow with [utilities/benchtable.go], the command is provided
in the Makefile as well (must run after generating the ` + "`bench.txt`" + ` with previous command):

` + "```sh" + `
make doc-bench
` + "```" + `

In the following subsections it is shown the results of each benchmark. The tables are autogenerated
from [bench.txt](bench.txt) file, and the implementation with better performance is marked with
a üèÜ in front of its name. It is recommended that you run the benchamarks for yourself though,
since the results may vary, see "Conclusion" bellow each table for the authors opinion.
`

type FuncDoc struct {
	Doc string
	Link string
}

func readFuncDocs(pkgName string) (map[string]FuncDoc, error) {
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, importPath, nil, parser.ParseComments)
	if err != nil {
		return nil, err
	}
	omapPkg, ok := pkgs[pkgName]
	if !ok {
		return nil, fmt.Errorf("package %q not found", pkgName)
	}
	omapDoc := doc.New(omapPkg, importPath, doc.AllDecls)
	ret := make(map[string]FuncDoc, len(omapDoc.Funcs))
	for _, fct := range omapDoc.Funcs {
		pos := fset.Position(fct.Decl.Type.Func)
		link := fmt.Sprintf("https://github.com/matheusoliveira/go-ordered-map/blob/main/%s#L%d", pos.Filename, pos.Line)
		ret[fct.Name] = FuncDoc{Doc: fct.Doc, Link: link}
	}
	return ret, nil
}

// Simple Markdown-like Table Builder
type AlignmentType int

const (
	AlignLeft AlignmentType = iota
	AlignRight
	//TODO: AlignCenter
)

type TableColumn struct {
	Title   string
	Align   AlignmentType
	VMerge  bool
	maxSize int
}

type Table struct {
	Columns []TableColumn
	rows    [][]string
}

func (t *Table) AddRow(cells ...any) {
	if len(cells) != len(t.Columns) {
		for i := len(cells); i < len(t.Columns); i++ {
			t.Columns = append(t.Columns, TableColumn{})
		}
	}
	if t.rows == nil {
		t.rows = make([][]string, 1, 2)
		t.rows[0] = make([]string, len(t.Columns))
		for i, c := range t.Columns {
			if len(c.Title) > c.maxSize {
				c.maxSize = len(c.Title)
				t.Columns[i] = c
			}
			t.rows[0][i] = c.Title
		}
	}
	row := make([]string, len(cells))
	for i, cell := range cells {
		col := t.Columns[i]
		str := fmt.Sprint(cell)
		if len(str) > col.maxSize {
			col.maxSize = len(str)
			t.Columns[i] = col
		}
		row[i] = str
	}
	t.rows = append(t.rows, row)
}

func (t *Table) Write(w io.Writer) (int, error) {
	var n int
	format := ""
	for _, col := range t.Columns {
		format += "| "
		if col.Align == AlignRight {
			format += "%" + strconv.Itoa(col.maxSize) + "s "
		} else {
			format += "%-" + strconv.Itoa(col.maxSize) + "s "
		}
	}
	format += "|\n"
	for i, row := range t.rows {
		strAsAny := make([]any, len(row))
		if i == 1 {
			// dotted line after title
			for j, col := range t.Columns {
				if col.Align == AlignRight {
					strAsAny[j] = strings.Repeat("-", col.maxSize-1) + ":"
				} else {
					strAsAny[j] = strings.Repeat("-", col.maxSize)
				}
			}
			ln, err := fmt.Fprintf(w, format, strAsAny...)
			n += ln
			if err != nil {
				return n, err
			}
		}
		for j, cell := range row {
			if t.Columns[j].VMerge && i > 1 && t.rows[i-1][j] == cell {
				strAsAny[j] = ""
			} else {
				strAsAny[j] = cell
			}
		}
		ln, err := fmt.Fprintf(w, format, strAsAny...)
		n += ln
		if err != nil {
			return n, err
		}
	}
	return n, nil
}

func (t *Table) Erase() {
	t.rows = nil
}

type BenchLine struct {
	Name     string
	SubName  string
	NRuns    int
	NsOp     int
	BOp      int
	AllocsOp int
	RawLine  string
}

func fmtInt(i int) string {
	if i == 0 {
		return "0"
	}
	str := ""
	if i < 0 {
		str = "-"
		i *= -1
	}
	for i != 0 {
		div := i % 1000
		i = i / 1000
		var divStr string
		if i == 0 {
			divStr = fmt.Sprintf("%d", div)
		} else {
			divStr = fmt.Sprintf("%03d", div)
		}
		if str == "" {
			str = divStr
		} else {
			str = divStr + "," + str
		}
	}
	return str
}

func processBenchmark(tbl *Table, w io.Writer, benchs []BenchLine, doc map[string]FuncDoc) {
	if len(benchs) == 0 {
		return
	}
	fmt.Fprintf(w, "## Benchmark %s\n\n", benchs[0].Name)
	// Process documentation
	var conclusionComment string
	var sourceCodeLink string
	const conclusionTag = "\nConclusion: "
	if doc != nil {
		name := "Benchmark"+benchs[0].Name
		if fd, ok := doc[name]; ok {
			if fd.Link != "" {
				sourceCodeLink = fmt.Sprintf("\n[Go to `%s` source code.](%s)\n", name, fd.Link)
			}
			// split comment and info
			s := strings.Split(fd.Doc, conclusionTag)
			fmt.Fprintln(w, s[0])
			if len(s) > 1 {
				fmt.Fprintln(w)
				conclusionComment = conclusionTag + strings.Join(s[1:], conclusionTag)
			}
		}
	}
	// Check the winner
	var winner string
	var minNsOp int
	for i, b := range benchs {
		if i == 0 || b.NsOp < minNsOp {
			winner = b.SubName
			minNsOp = b.NsOp
		}
	}
	// Process lines
	var rawLines strings.Builder
	baseline := 0
	for i, b := range benchs {
		var perfCmp string
		if i == 0 && (b.SubName == "map" || b.SubName == "Builtin") {
			baseline = b.NsOp
			perfCmp = "baseline"
		} else if baseline != 0 {
			perfCmpF := float64(baseline)/float64(b.NsOp) - 1
			perfCmp = fmt.Sprintf("%.2f %%", perfCmpF*100)
		}
		subName := b.SubName
		if b.SubName == winner {
			subName = "**" + subName + "** üèÜ"
		}
		tbl.AddRow(subName, fmtInt(b.NRuns), fmtInt(b.NsOp), fmtInt(b.BOp), fmtInt(b.AllocsOp), perfCmp)
		if i != 0 {
			rawLines.WriteString("\n")
		}
		rawLines.WriteString(b.RawLine)
	}
	tbl.Write(w)
	fmt.Fprintln(w, conclusionComment)
	tbl.Erase()
	// raw
	fmt.Fprintln(w, sourceCodeLink)
	fmt.Fprintln(w, "<details>")
	fmt.Fprintln(w, "<summary><b>Raw output:</b></summary>")
	fmt.Fprintln(w)
	fmt.Fprintln(w, "```")
	fmt.Fprintln(w, rawLines.String())
	fmt.Fprintln(w, "```")
	fmt.Fprintln(w, "</details>")
}

func getMainReaderWritter() (io.ReadCloser, io.WriteCloser, error) {
	// in
	inputFilename := "docs/bench.txt"
	if len(os.Args) >= 2 {
		inputFilename = os.Args[1]
	}
	inputReader, err := os.Open(inputFilename)
	if err != nil {
		return nil, nil, err
	}
	// out
	outputFilename := "docs/benchmarks.md"
	if len(os.Args) >= 3 {
		outputFilename = os.Args[2]
	}
	outputWriter, err := os.Create(outputFilename)
	if err != nil {
		return inputReader, nil, err
	}
	return inputReader, outputWriter, nil
}

func closeIfNotNil(obj io.Closer) {
	if obj != nil {
		obj.Close()
	}
}

func processLines(in io.Reader) <-chan []BenchLine {
	outCh := make(chan []BenchLine)
	// Bench output processor
	reIsBench := regexp.MustCompile("^Benchmark")
	reProcBench := regexp.MustCompile(`^Benchmark([^/]+)/([^-]+)-\d+\s+(\d+)((\s+(\d+)\s(\S+))*)$`)
	reProcParams := regexp.MustCompile(`\s*(\d+)\s(\S+)`)
	go func() {
		benchs := []BenchLine{}
		scanner := bufio.NewScanner(in)
		lastBench := ""
		for scanner.Scan() {
			line := scanner.Text()
			if !reIsBench.MatchString(line) {
				continue
			}
			matches := reProcBench.FindAllStringSubmatch(line, -1)
			for _, m := range matches {
				b := BenchLine{}
				b.RawLine = line
				b.Name = m[1]
				b.SubName = m[2]
				b.NRuns, _ = strconv.Atoi(m[3])
				params := m[4]
				pmatches := reProcParams.FindAllStringSubmatch(params, -1)
				for _, pm := range pmatches {
					v, _ := strconv.Atoi(pm[1])
					switch pm[2] {
					case "ns/op":
						b.NsOp = v
					case "B/op":
						b.BOp = v
					case "allocs/op":
						b.AllocsOp = v
					}
				}
				if lastBench != b.Name {
					outCh <- benchs
					benchs = []BenchLine{b}
				} else {
					benchs = append(benchs, b)
				}
				lastBench = b.Name
			}
		}
		if len(benchs) > 0 {
			outCh <- benchs
		}
		close(outCh)
	}()
	return outCh
}

func main() {
	var err error
	// in/out
	in, out, err := getMainReaderWritter()
	defer closeIfNotNil(in)
	defer closeIfNotNil(out)
	if err != nil {
		log.Fatal(err)
	}
	// Process documentation
	doc, err := readFuncDocs("omap_test")
	if err != nil {
		log.Fatalf("Could not read documentation. Error: %v\n\n. Proceding without doc...", err)
	}
	// Introduction text
	fmt.Fprintln(out, introductionText)
	// Table columns setup
	tbl := Table{
		Columns: []TableColumn{
			//{Title: "Bench", VMerge: true},
			{Title: "Implemenation"},
			{Title: "Nruns", Align: AlignRight},
			{Title: "ns/op", Align: AlignRight},
			{Title: "B/op", Align: AlignRight},
			{Title: "allocs/op", Align: AlignRight},
			{Title: "% perf relative", Align: AlignRight},
		},
	}
	// Process lines
	for benchs := range processLines(in) {
		processBenchmark(&tbl, out, benchs, doc)
		fmt.Fprintln(out)
	}
}
